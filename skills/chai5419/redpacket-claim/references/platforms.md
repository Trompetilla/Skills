# 红包平台技术文档

各平台红包领取的技术实现方式和接口说明。

## 微信红包 (WeChat)

### 接口类型
1. **网页版接口**（已基本停用）
2. **小程序接口**（主流）
3. **客户端模拟**（需要特殊权限）

### 领取流程
```
1. 获取红包口令
2. 打开微信小程序/网页
3. 输入口令
4. 点击领取
5. 验证领取结果
```

### 技术要点
- **User-Agent**: 需模拟微信客户端
- **Referer**: 需要正确的来源页面
- **Cookie**: 需要有效的登录态
- **风控策略**: 频率限制、设备指纹

### 示例请求
```http
POST /redpacket/claim HTTP/1.1
Host: wx.qq.com
User-Agent: MicroMessenger/8.0.42
Content-Type: application/json
Cookie: wxuin=xxx; wxsid=xxx

{
  "code": "天天开心",
  "channel": "miniapp",
  "device_id": "xxx"
}
```

## 支付宝红包 (Alipay)

### 接口类型
1. **开放平台API**（需要商户资质）
2. **H5页面接口**（对用户友好）
3. **小程序接口**（支付宝内使用）

### 领取流程
```
1. 识别支付宝口令格式
2. 唤起支付宝APP或打开H5
3. 自动填充口令
4. 点击领取到余额
5. 返回领取凭证
```

### 技术要点
- **URL Scheme**: alipays://platformapi/startapp
- **H5页面**: https://render.alipay.com/p/
- **身份验证**: access_token 或 auth_code
- **结果回调**: 同步/异步通知

### 示例URL
```
alipays://platformapi/startapp?appId=xxx&page=pages/redpacket/claim&query=code%3Dxxxx
```

## QQ红包 (QQ)

### 接口类型
1. **QQ钱包接口**（需要QQ登录）
2. **QQ群红包API**（群聊场景）
3. **H5页面领取**（兼容性好）

### 领取流程
```
1. 检测QQ消息格式
2. 调用QQ红包接口
3. 验证群成员身份
4. 领取到QQ钱包
5. 发送领取通知
```

### 技术要点
- **QQ登录**: 需要 skey、p_skey
- **群聊验证**: 需要群ID和成员身份
- **消息格式**: 特定XML格式
- **风控**: 同设备多账号限制

### 消息格式
```xml
<msg>
  <redpacket>
    <code>恭喜发财</code>
    <type>normal</type>
    <from>123456</from>
    <group>888888</group>
  </redpacket>
</msg>
```

## 抖音红包 (Douyin)

### 接口类型
1. **短视频红包**（视频内嵌）
2. **直播红包**（直播间发放）
3. **活动红包**（营销活动）

### 领取流程
```
1. 打开抖音APP
2. 进入红包活动页面
3. 输入口令或点击领取
4. 观看视频/完成互动
5. 领取到抖币/现金
```

### 技术要点
- **APP唤起**: snssdk1128://
- **WebView**: 需要抖音内嵌浏览器
- **设备绑定**: 强设备指纹验证
- **行为验证**: 可能需要滑动验证

## 快手红包 (Kuaishou)

### 接口类型
1. **直播红包**（主播发放）
2. **视频红包**（视频内容）
3. **任务红包**（完成活动）

### 领取流程
类似抖音，但接口略有不同

## 通用平台适配策略

### 平台检测优先级
```python
PLATFORM_PRIORITY = [
    ("微信", 0.9),      # 识别度最高
    ("支付宝", 0.85),
    ("QQ", 0.8),
    ("抖音", 0.75),
    ("快手", 0.7),
    ("其他", 0.5)
]
```

### 智能路由逻辑
1. 根据消息来源判断
2. 根据口令格式判断
3. 根据用户历史偏好
4. 根据平台可用性

### 降级策略
1. 主平台失败 → 备用平台
2. 接口失败 → 模拟点击
3. 自动失败 → 手动引导

## 安全与风控

### 平台风控特征
| 平台 | 频率限制 | 设备指纹 | 行为分析 | 验证码 |
|------|----------|----------|----------|--------|
| 微信 | 严格 | 强 | 中等 | 偶尔 |
| 支付宝 | 中等 | 中等 | 弱 | 很少 |
| QQ | 中等 | 中等 | 中等 | 偶尔 |
| 抖音 | 严格 | 强 | 强 | 经常 |
| 快手 | 中等 | 强 | 中等 | 偶尔 |

### 规避策略
1. **延迟随机化**: 1-5秒随机延迟
2. **设备模拟**: 轮换User-Agent
3. **IP轮换**: 使用代理池
4. **行为模拟**: 模仿真人操作模式
5. **失败处理**: 智能暂停和恢复

## 错误代码说明

### 通用错误
```
1001: 口令格式错误
1002: 口令已过期
1003: 红包已领完
1004: 频率限制
1005: 身份验证失败
1006: 网络超时
1007: 平台维护中
1008: 账户异常
```

### 平台特定错误
- **微信**: 2001-2099
- **支付宝**: 3001-3099
- **QQ**: 4001-4099
- **抖音**: 5001-5099
- **快手**: 6001-6099

## 性能优化

### 并发处理
```python
# 异步批量处理
async def batch_claim(codes: List[str]):
    semaphore = asyncio.Semaphore(5)  # 并发限制
    tasks = [claim_with_semaphore(code, semaphore) for code in codes]
    return await asyncio.gather(*tasks, return_exceptions=True)
```

### 缓存策略
1. **口令缓存**: 避免重复处理
2. **平台状态缓存**: 记录平台可用性
3. **用户偏好缓存**: 学习用户习惯
4. **结果缓存**: 临时存储领取结果

### 监控指标
- 领取成功率
- 平均响应时间
- 平台分布比例
- 错误类型统计
- 用户满意度

## 扩展开发

### 添加新平台
1. 继承 `RedPacketClaimer` 基类
2. 实现 `can_handle` 和 `claim` 方法
3. 在平台文档中注册
4. 更新配置文件验证

### 插件架构
```python
# 插件发现机制
PLUGINS = {}

def register_platform(name: str, claimer_class):
    PLUGINS[name] = claimer_class

def load_plugins():
    # 自动发现并加载插件
    pass
```

## 测试与验证

### 测试用例
```python
class TestRedPacketClaimer:
    def test_code_extraction(self):
        # 测试口令提取
        pass
    
    def test_platform_detection(self):
        # 测试平台识别
        pass
    
    def test_claim_simulation(self):
        # 测试领取模拟
        pass
```

### 集成测试
1. **单元测试**: 核心逻辑验证
2. **集成测试**: 平台接口验证
3. **压力测试**: 高并发场景
4. **兼容性测试**: 多平台覆盖

## 部署与运维

### 环境要求
- Python 3.8+
- 网络访问权限
- 本地存储权限
- 可能的移动设备连接

### 配置管理
1. 平台密钥安全存储
2. 用户配置持久化
3. 运行参数动态调整
4. 日志轮转和归档

### 监控告警
- 成功率低于阈值告警
- 响应时间超时告警
- 平台不可用告警
- 异常行为检测告警

---

*最后更新：2026-02-11*